# 一、Hello world
```c
// include：包含、std：标准、standard io、.h：c语言独特的头文件
#include <stdio.h> // 导入标准输入输出的头文件

int main(void) {
	printf("Hello，world！\n");
	return 0;
}
```
![[Pasted image 20240131150525.png]]
![[Pasted image 20240201180831.png]]
# 二、指针
- 指针全称是指针变量，其实质是 C 语言的一种变量。
	- 通常它的值会被赋值为某个变量的地址值 `p = &a`
		- 然后我们可以使用 `*p` 这样的方式去间接访问 p 所指向的那个变量。
```c
static void myPoint() {
	int num = 1;
	/**
	* 定义一个指针变量/类型
	* 1. int* 表示类型为 指针类型
	* 2. ptr 指向了一个int类型变量的地址
	*/
	int* ptr = &num;
	/**
	* 输出变量num的地址：
	* 1. %p：输出变量地址
	* 2. &num: 表示取出num这个变量对应地址
	*/
	printf("num 的值 = %d,num 地址 = %p", num, &num);
	printf("ptr 指向的值 = %d,ptr 本身的地址 = %p, ptr 存放的值是一个地址 = %p\n", *ptr, &ptr, ptr);
}
```
![[Pasted image 20240131194606.png]]
![[Pasted image 20240131194903.png]]
![[Pasted image 20240131201435.png]]
## 2.1 为什么需要指针？

指针的存在主要是为了实现间接访问。有了指针，我们可以通过 `p = &a; *p = xxx;` 的方式间接访问变量 `a`，而不必直接使用变量名 `a`。

## 2.2 两种重要运算符：& 和 *

- `&`：取地址运算符，用于获取变量的地址值。例如，`&a` 表示变量 `a` 的地址值。
- `*`：解引用运算符，用于访问指针所指向的变量。例如，`*p` 表示指针 `p` 所指向的变量。

在指针定义和指针操作时，`*` 的解析方法有所不同：

- 在定义时，如 `int *p;`，这里的 `*` 表示 `p` 是一个指针变量。
- 在解引用时，如 `*p`，这里的 `*` 表示访问指针 `p` 所指向的变量。

## 2.3 指针的定义和初始化

指针作为一种变量，可以进行定义和初始化。

### 定义和赋值的两种方式：

1. 先定义再赋值：


```c
int *p;
p = &a;
```
2. 定义的同时初始化：


```c
int *p = &a;
```
## 2.4 各种不同类型的指针

指针变量的类型决定了它所指向的变量的类型。例如，`int *p;` 定义了一个指向 `int` 类型变量的指针 `p`。

- `int *pInt;`：`pInt` 是指针变量，指向的变量是 `int` 类型。
- `char *pChar;`：`pChar` 是指针变量，指向的变量是 `char` 类型。
- `float *pFloat;`
- `double *pDouble;`

指针类型和它所指向的变量类型必须匹配，否则结果不可预知。

## 2.5 指针定义的两种理解方法

对于 `int *p;`，有两种理解方法：

1. `p` 是变量名，`*` 表示 `p` 是一个指针变量，`int *` 表示这个指针变量 `p` 指向的是一个 `int` 类型的数据。
2. `p` 是变量名，`int *` 整体作为类型来理解，表示指向 `int` 类型数据的指针类型。

## 2.6 指针与数组的初步结合

数组名作为右值时，表示数组的首元素地址，因此可以直接赋值给指针。例如，对于 `int a[5];`，`a` 和 `&a[0]` 都表示数组首元素 `a[0]` 的首地址。而 `&a` 表示数组的整体地址。

可以用指针指向数组的第一个元素，通过解引用操作逐个访问数组中的元素。

例如，对于 `int a[5]; int *p; p = a;`，可以通过以下两种方式访问数组元素：

- 数组方式：`a[0]`, `a[1]`, `a[2]`, `a[3]`, `a[4]`
- 指针方式：`*p`, `*(p+1)`, `*(p+2)`, `*(p+3)`, `*(p+4)`

## 2.7 指针与 ++、-- 符号进行运算

指针本身也是一种变量，因此可以进行运算。但由于指针变量存储的是其他变量的地址值，所以进行 `*`、`/`、`%` 等运算无意义。两个指针变量相加也无意义，但相减是有意义的。指针变量 `+1` 和 `-1` 是有意义的，分别表示指针向后移动一个格子和向前移动一个格子。
- `*p++` 执行流程：`*p++` 相当于 `*(p++)`
	- 先执行 `p++`，然后解引用 `*p`
	- 因为 `++` 后置时，先执行运算（即 `p++` 整体与前面的 `*` 进行运算），再增加 1（即 `p+1`）
		- 所以 `*p++` 的结果是 `*p` 的值，运算完成后 `p` 再加 1
	- 所以 `*p++` 等同于：`*p; p += 1;`
- `*++p` 等同于 `p += 1;	*p;`
- `(*p)++`，使用 ()强制将 `*` 与 `p` 结合，只能先计算 `*p`，然后对 `*p` 整体的值++。
- `++(*p)`，先 `*p` 取值，再前置++，该值+1 后作为整个表达式的值。
总结：++符号和指针结合，总共有以上 4 种情况。--与++的情况很类似。
## 2.8 函数传参中使用指针
> c 语言中，函数调用时，实参传递给形参实际是传值调用。

`int add (int a, int b)` 函数传参使用了 int 型数，本身是数值类型。
实际调用该函数时，实参将自己拷贝一份，并将拷贝传递给形参进行运算。
实参自己实际是不参与的。所以，在函数中，是没法改变实参本身的。
# 三、值传递和地址传递
C 语言传递参数（或者赋值）可以是值传递也可以传递指针 (地址传递)。
![[Pasted image 20240131203516.png]]
1. 默认传递值的类型：基本数据类型（整型类型、小数类型，字符类型），结构体共用体。
2. 默认传递地址的类似：指针、数组
![[C语言指针问题.excalidraw]]
# 四、const 和 `#define` 的区别
1. const 定义的常量时，带类型，define. 不带类型
2. const 是在编译、运行的时候起作用，而 define 是在编译的预处理阶段起作用
3. define 只是简单的替换，没有类型检查。简单的字符串替换会导致**边界效应**
4. const 常量可以进行调试的，define 是不能进行调试的，主要是预编译阶段就已经替换掉了，调试的时候就没它了
5. const 不能重定义，不可以定义两个一样的，而 define 通过 undef 取消某个符号的定义，再重新定义
6. define 可以配合 `#ifdef` 、 `#ifndef` 、 `#endif` 来使用，可以让代码更加灵活，比如我们可以通过 define 来启动或者关闭调试信
```c
#define DEBUG
static void define() {
#ifdef DEBUG
	printf("定义过DEBUG\n");
#endif // 如果定义过DEBUG 
#ifndef TEST
	printf("没有定义过TEST环境\n");
#endif // !DEBUG
}
```
# 五、运算符优先级
![[Pasted image 20240131233424.png]]
# 六、进制之间转换
![[Pasted image 20240201112628.png]]
![[Pasted image 20240201112806.png]]
![[Pasted image 20240201112847.png]]
![[Pasted image 20240201114129.png]]
# 七、原码、反码、补码
- 对于有符号的而言：
	1. 二进制的最高位是符号位：0 表示正数、1 表示负数
	2. 正数的原码、反码、补码都一样 (三码合一)
	3. 负数的反码=他的原码符号位不变，其它位取反（0—>1，1—>0）
	4. 负数的补码 = 它的反码+1
	5. 0 的反码、补码都是 0
	6. 在计算机运算时，都是以**补码的方式**来运算的

原码、反码和补码是计算机中表示数值的几种方式，主要用于二进制数的加法和减法操作。

1. **原码（Original Code）**:
原码就是直接将二进制数的每一位（包括符号位）转换成相应的十进制数。例如，对于 8 位二进制数来说，如果最高位是符号位，那么剩下的 7 位表示实际的数值。
* 例如
	* 二进制数 00000000（0）在原码中表示为 00000000（0）
	* 二进制数 00010101（21）在原码中表示为 00010101（21）
	* 二进制数 10010101（-29）在原码中表示为 10010101（-29）
2. **反码（One's Complement）**:
反码是在原码的基础上，正数的反码与其原码相同；负数的反码是对其原码逐位取反（但符号位除外）。
* 例如：
	* 二进制数 00000000（0）在反码中仍表示为 00000000（0）
	* 二进制数 00010101（21）在反码中表示为 00010101（21）
	* 二进制数 10010101（-29）在反码中表示为 11101010（-29）
3. **补码（Twos Complement）**:
补码是在反码的基础上加 1。对于负数，补码就是对其反码加 1。正数的补码与其原码相同。
* 例如：
	* 二进制数 00000000（0）在补码中仍表示为 00000000（0）
	* 二进制数 00010101（21）在补码中表示为 00010101（21）
	* 二进制数 10010101（-29）在补码中表示为 11101111（-29）

在计算机内部，所有的数值都是用补码来表示的，这样可以简化运算并且方便计算机处理。加法和减法操作可以统一使用加法器完成，只要确保减数的补码是其原码的按位取反再加一。

[视频地址](https://www.bilibili.com/video/BV1kh411d7Dq?p=57&vd_source=c694526ad958a6026a9455097a141295)

# 八、位运算
- 规则：
	1. 按位与&：两位全为 1，结果为 1，否则为 0
	2. 按位或|：两位有一个为 1，结果为 1，否则为 0
	3. 按位异或^：两位一个为 0，一个为 1，否则为 0
	4. 按位取反：0 -> 1, 1 -> 0

# 九、宏定义
>[!note-] 基本介绍：`#define` 叫做宏定义命令，就是用一个标识符来表示一个字符串，如果后面代码出现该标识符则替换

![[Pasted image 20240131230131.png]]

# 十、数组
![[Pasted image 20240201202049.png]]
- 字符指针变量 vs 字符数组两种表示字符串区别
	- 字符数组由若干个元素组成，每个元素放一个字符
		- 字符指针变量中存放的是地址 (字符串/字符数组的首地址)
	- 字符数组只能对各个元素赋值，不能用以下方法对字符数组赋值
		```c
		char str[14];
		str = "hello tom"; // x
		str[0] = "h"; // √
		```
	- 对字符指针变量，采用下面方法赋值，是可以的
		```c
		char* a;
		a = "hello tom";
		```